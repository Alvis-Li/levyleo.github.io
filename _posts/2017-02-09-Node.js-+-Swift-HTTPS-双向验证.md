---
title: Node.js(restify) + Swift HTTPS åŒå‘éªŒè¯
---

ç›¸å…³è¯ä¹¦ç”Ÿæˆ å‚ç…§: [Node.Js TLS(SSL) HTTPSåŒå‘éªŒè¯](http://blog.csdn.net/marujunyy/article/details/8477854)

åœ¨è¿™åªç®€å•è®°å½•è¿‡ç¨‹,æ›´è¯¦ç»†çš„çœ‹ä¸Šé¢ğŸ‘†åŸæ–‡

è‡ªç­¾åçš„CAè¯ä¹¦:

```
openssl genrsa -out ca-key.pem -des 1024  

openssl req -new -key ca-key.pem -out ca-csr.pem  

openssl x509 -req -days 3650 -in ca-csr.pem -signkey ca-key.pem -out ca-cert.pem 
```



ç”ŸæˆæœåŠ¡å™¨ç§é’¥åŠè¯ä¹¦:

```
openssl genrsa -out server-key.pem 1024  

openssl req -new -key server-key.pem -out server-csr.pem  

openssl x509 -req -days 730 -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -in server-csr.pem -out server-cert.pem -extensions v3_req  

```

ç”Ÿæˆå®¢æˆ·ç«¯è¯ä¹¦ï¼š

```
openssl genrsa -out client-key.pem  

openssl req -new -key client-key.pem -out client-csr.pem  

openssl x509 -req -days 365 -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -in client-csr.pem -out client-cert.pem 

```

æœåŠ¡å™¨ç§é’¥ã€è¯ä¹¦ä»¥åŠCAè¯ä¹¦æ‰“åŒ…æˆä¸€ä¸ªå•ç‹¬çš„.pfxæˆ–.p12æ–‡ä»¶ï¼š

```
openssl pkcs12 -export -in server-cert.pem -inkey server-key.pem -certfile ca-cert.pem -out server.pfx
```



```
openssl pkcs12 -export -in client-cert.pem -inkey client-key.pem -certfile ca-cert.pem -out client.p12
```



ç”Ÿæˆæ–‡ä»¶:

```
ca-cert.pem  ca-csr.pem  client-cert.pem  client-key.pem  server-cert.pem  server-key.pem  
ca-cert.srl  ca-key.pem  client-csr.pem   client.p12      server-csr.pem   server.pfx
```



Node.js æœåŠ¡å™¨ä»£ç : (ä½¿ç”¨restify)

```javascript
var restify=require('restify');
var fs=require('fs');

var server=restify.createServer({
    certificate: fs.readFileSync('server-cert.pem'),
    key: fs.readFileSync('server-key.pem'),
    requestCert: true
});

server.get('/', function(req, res, next) {
	res.send(200,"{}");
});
server.listen(8000, function() {
    console.log('servers up...');
});
```

Swift å®¢æˆ·ç«¯ä»£ç (app):(ä½¿ç”¨Alamofire)

```swift
import Alamofire
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        //è®¤è¯ç›¸å…³è®¾ç½®
        let manager = SessionManager.default
        manager.delegate.sessionDidReceiveChallenge = { session, challenge in
            if challenge.protectionSpace.authenticationMethod
                == NSURLAuthenticationMethodServerTrust
            {
                print("æœåŠ¡ç«¯è¯ä¹¦è®¤è¯ï¼")
                let serverTrust:SecTrust = challenge.protectionSpace.serverTrust!
                let certificate = SecTrustGetCertificateAtIndex(serverTrust, 0)!
                let remoteCertificateData :Data
                    = CFBridgingRetain(SecCertificateCopyData(certificate))! as! Data
                let cerPath = Bundle.main.path(forResource: "192.168.10.18", ofType: "cer")!
                let cerUrl = URL(fileURLWithPath:cerPath)
                
                let localCertificateData = try! Data(contentsOf: cerUrl)
               
                
                if (remoteCertificateData == localCertificateData) {
                    let credential = URLCredential(trust: serverTrust)
                    challenge.sender?.use(credential, for: challenge)
                    return (URLSession.AuthChallengeDisposition.useCredential,
                            URLCredential(trust: challenge.protectionSpace.serverTrust!))
                } else {
                    return (.cancelAuthenticationChallenge, nil)
                }
            }
                //è®¤è¯å®¢æˆ·ç«¯è¯ä¹¦
            else if challenge.protectionSpace.authenticationMethod
                == NSURLAuthenticationMethodClientCertificate {
                print("å®¢æˆ·ç«¯è¯ä¹¦è®¤è¯ï¼")
                //è·å–å®¢æˆ·ç«¯è¯ä¹¦ç›¸å…³ä¿¡æ¯
                let identityAndTrust:IdentityAndTrust = self.extractIdentity();
                
                let urlCredential:URLCredential = URLCredential(
                    identity: identityAndTrust.identityRef,
                    certificates: identityAndTrust.certArray as? [AnyObject],
                    persistence: URLCredential.Persistence.forSession);
                
                return (.useCredential, urlCredential);
            }
                // å…¶å®ƒæƒ…å†µï¼ˆä¸æ¥å—è®¤è¯ï¼‰
            else {
                print("å…¶å®ƒæƒ…å†µï¼ˆä¸æ¥å—è®¤è¯ï¼‰")
                return (.cancelAuthenticationChallenge, nil)
            }
            
        }
        
        //æ•°æ®è¯·æ±‚
        Alamofire.request("https://192.168.10.18:8000")
            .responseString { response in
                print(response)
        }
        
        
    }
    
    func extractIdentity() -> IdentityAndTrust {
        var identityAndTrust:IdentityAndTrust!
        var securityError:OSStatus = errSecSuccess
        
        let path: String = Bundle.main.path(forResource: "client", ofType: "p12")!
        let PKCS12Data = NSData(contentsOfFile:path)!
        let key : NSString = kSecImportExportPassphrase as NSString
        let options : NSDictionary = [key : "XXX"] //å®¢æˆ·ç«¯è¯ä¹¦å¯†ç 
        //create variable for holding security information
        //var privateKeyRef: SecKeyRef? = nil
        
        var items : CFArray?
        
        securityError = SecPKCS12Import(PKCS12Data, options, &items)
        
        if securityError == errSecSuccess {
            let certItems:CFArray = items as CFArray!;
            let certItemsArray:Array = certItems as Array
            let dict:AnyObject? = certItemsArray.first;
            if let certEntry:Dictionary = dict as? Dictionary<String, AnyObject> {
                // grab the identity
                let identityPointer:AnyObject? = certEntry["identity"];
                let secIdentityRef:SecIdentity = identityPointer as! SecIdentity!
//                print("\(identityPointer)  :::: \(secIdentityRef)")
                // grab the trust
                let trustPointer:AnyObject? = certEntry["trust"]
                let trustRef:SecTrust = trustPointer as! SecTrust
//                print("\(trustPointer)  :::: \(trustRef)")
                // grab the cert
                let chainPointer:AnyObject? = certEntry["chain"]
                identityAndTrust = IdentityAndTrust(identityRef: secIdentityRef,
                                                    trust: trustRef, certArray:  chainPointer!)
            }
        }
        return identityAndTrust;
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    
}

//å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ï¼Œå­˜å‚¨è®¤è¯ç›¸å…³ä¿¡æ¯
struct IdentityAndTrust {
    var identityRef:SecIdentity
    var trust:SecTrust
    var certArray:AnyObject
}
```

ps:æ–‡ä»¶ä¸­å¹¶æ²¡æœ‰ç”Ÿæˆ.ceråç¼€çš„æ–‡ä»¶,æœ¬ç€å·æ‡’çš„åŸåˆ™,ç›´æ¥æµè§ˆå™¨è®¿é—®https://192.168.10.18:8000,ä¼šå‡ºç°æç¤ºæ¡†ä¿¡ä»»è¯ä¹¦,åœ¨é’¥åŒ™ä¸²ä¸­æ‰¾åˆ°è¯¥è¯ä¹¦,å¯¼å‡º.cer